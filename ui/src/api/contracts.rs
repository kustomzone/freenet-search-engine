use freenet_stdlib::client_api::{ClientRequest, ContractRequest};
use freenet_stdlib::prelude::{ContractInstanceId, ContractKey};
use web_sys::WebSocket;

use crate::state::{CATALOG_STATE, SHARDS_AVAILABLE, SHARD_STATES};
use search_common::types::{CatalogState, ShardState};

use super::node_api::send_request;

// Auto-generated by deploy-helper. Regenerate with: cargo run -p deploy-helper
const CATALOG_INSTANCE_ID: [u8; 32] = [
    33, 157, 110, 205, 193, 48, 120, 103, 12, 33, 156, 91, 70, 161, 180, 44, 4, 228, 238, 121, 93,
    223, 26, 99, 2, 52, 6, 117, 137, 196, 66, 197,
];

const SHARD_INSTANCE_IDS: [[u8; 32]; 16] = [
    [
        141, 81, 193, 246, 227, 56, 210, 186, 149, 159, 169, 210, 74, 50, 22, 192, 216, 212, 112,
        79, 168, 181, 120, 29, 52, 134, 55, 120, 29, 64, 242, 52,
    ],
    [
        93, 180, 169, 98, 11, 176, 26, 248, 94, 21, 47, 22, 241, 229, 47, 224, 10, 227, 181, 1,
        118, 53, 201, 68, 207, 53, 150, 96, 44, 82, 184, 232,
    ],
    [
        104, 62, 235, 206, 220, 38, 30, 197, 252, 95, 166, 210, 106, 20, 210, 162, 33, 97, 173,
        235, 22, 160, 196, 10, 28, 205, 57, 26, 158, 98, 7, 206,
    ],
    [
        108, 175, 145, 90, 217, 8, 218, 60, 159, 9, 124, 192, 213, 71, 10, 16, 117, 197, 44, 200,
        214, 75, 176, 71, 126, 61, 188, 242, 31, 241, 194, 243,
    ],
    [
        145, 168, 38, 223, 223, 211, 113, 127, 98, 147, 29, 152, 32, 161, 130, 191, 181, 50, 217,
        114, 161, 10, 140, 110, 163, 229, 117, 49, 7, 253, 50, 17,
    ],
    [
        7, 175, 128, 163, 56, 87, 239, 23, 170, 101, 229, 176, 118, 88, 57, 241, 45, 159, 50, 91,
        100, 56, 124, 210, 31, 28, 74, 237, 8, 107, 193, 111,
    ],
    [
        163, 98, 51, 252, 8, 71, 222, 240, 203, 237, 180, 149, 210, 177, 79, 40, 240, 158, 29, 209,
        184, 229, 100, 238, 26, 25, 32, 148, 95, 203, 36, 205,
    ],
    [
        218, 13, 144, 77, 240, 40, 223, 174, 102, 42, 172, 172, 47, 113, 123, 36, 98, 153, 189,
        157, 92, 63, 66, 214, 164, 30, 67, 209, 132, 135, 73, 72,
    ],
    [
        175, 64, 101, 115, 50, 170, 85, 162, 40, 75, 154, 86, 227, 233, 116, 106, 192, 207, 0, 186,
        201, 236, 246, 11, 113, 165, 243, 34, 172, 225, 77, 20,
    ],
    [
        234, 86, 188, 248, 21, 149, 67, 89, 60, 121, 191, 110, 48, 133, 246, 218, 222, 87, 34, 94,
        81, 25, 126, 242, 18, 48, 149, 202, 175, 160, 202, 72,
    ],
    [
        171, 45, 38, 32, 228, 255, 114, 4, 129, 108, 56, 228, 206, 163, 86, 28, 168, 15, 21, 239,
        204, 153, 170, 16, 161, 31, 230, 7, 43, 51, 201, 158,
    ],
    [
        56, 250, 146, 167, 78, 209, 167, 203, 193, 244, 254, 188, 75, 44, 229, 196, 19, 243, 94,
        70, 98, 46, 201, 78, 54, 145, 53, 152, 222, 200, 74, 150,
    ],
    [
        196, 109, 42, 85, 235, 183, 156, 237, 173, 152, 190, 241, 244, 91, 131, 182, 55, 173, 63,
        230, 72, 243, 173, 216, 82, 221, 73, 153, 175, 28, 108, 221,
    ],
    [
        156, 131, 59, 212, 161, 67, 210, 183, 60, 107, 198, 50, 90, 164, 44, 144, 161, 52, 33, 97,
        61, 44, 129, 26, 55, 92, 101, 250, 48, 155, 2, 214,
    ],
    [
        87, 62, 181, 162, 162, 47, 7, 123, 59, 232, 230, 73, 200, 249, 8, 104, 146, 69, 125, 183,
        69, 216, 188, 175, 141, 190, 168, 252, 163, 15, 93, 225,
    ],
    [
        155, 94, 174, 135, 163, 238, 132, 106, 52, 112, 253, 125, 82, 221, 239, 93, 165, 118, 35,
        31, 230, 91, 28, 236, 242, 32, 61, 134, 201, 106, 15, 200,
    ],
];

fn catalog_instance_id() -> ContractInstanceId {
    ContractInstanceId::new(CATALOG_INSTANCE_ID)
}

fn shard_instance_id(shard_id: u8) -> ContractInstanceId {
    ContractInstanceId::new(SHARD_INSTANCE_IDS[shard_id as usize])
}

/// Subscribe to the catalog contract state with updates.
pub fn subscribe_catalog(ws: &WebSocket) {
    let request = ClientRequest::ContractOp(ContractRequest::Get {
        key: catalog_instance_id(),
        return_contract_code: false,
        subscribe: true,
        blocking_subscribe: false,
    });
    send_request(ws, &request);
    tracing::info!("Subscribed to catalog contract");
}

/// Subscribe to a single shard contract state with updates.
pub fn subscribe_shard(ws: &WebSocket, shard_id: u8) {
    let request = ClientRequest::ContractOp(ContractRequest::Get {
        key: shard_instance_id(shard_id),
        return_contract_code: false,
        subscribe: true,
        blocking_subscribe: false,
    });
    send_request(ws, &request);
    tracing::debug!("Subscribed to shard contract {}", shard_id);
}

/// Handle a catalog contract GET response: deserialize CBOR and update signals.
pub fn handle_catalog_response(state_bytes: &[u8]) {
    match ciborium::from_reader::<CatalogState, _>(state_bytes) {
        Ok(catalog) => {
            tracing::info!(
                "Catalog state loaded: {} entries, {} contributors",
                catalog.entries.len(),
                catalog.contributors.len()
            );
            cache_to_local_storage("catalog_state", state_bytes);
            *CATALOG_STATE.write() = Some(catalog);
        }
        Err(e) => {
            tracing::warn!("Failed to deserialize catalog state: {}", e);
        }
    }
}

/// Handle a shard contract GET response: deserialize CBOR and update signals.
pub fn handle_shard_response(state_bytes: &[u8]) {
    match ciborium::from_reader::<ShardState, _>(state_bytes) {
        Ok(shard) => {
            let shard_id = shard.shard_id;
            let term_count = shard.index.len();
            tracing::debug!("Shard {} state loaded: {} terms", shard_id, term_count,);
            cache_to_local_storage(&format!("shard_state_{}", shard_id), state_bytes);

            let mut states = SHARD_STATES.write();
            states.insert(shard_id, shard);
            let available = states.len() as u8;
            drop(states);
            *SHARDS_AVAILABLE.write() = available;
        }
        Err(e) => {
            tracing::warn!("Failed to deserialize shard state: {}", e);
        }
    }
}

/// Check if a contract key matches the catalog contract.
pub fn is_catalog_key(key: &ContractKey) -> bool {
    key.id().as_bytes() == catalog_instance_id().as_bytes()
}

/// Check if a contract key matches any shard contract, returning the shard_id.
pub fn matching_shard_id(key: &ContractKey) -> Option<u8> {
    let key_bytes = key.id().as_bytes();
    (0u8..16).find(|&shard_id| key_bytes == shard_instance_id(shard_id).as_bytes())
}

/// Get the catalog contract instance ID (for use in Update requests).
pub fn catalog_contract_key() -> ContractInstanceId {
    catalog_instance_id()
}

/// Get a shard contract instance ID (for use in Update requests).
pub fn shard_contract_key(shard_id: u8) -> ContractInstanceId {
    shard_instance_id(shard_id)
}

/// Load cached catalog and shard states from localStorage on startup.
pub fn load_cached_states() {
    if let Some(bytes) = load_from_local_storage("catalog_state") {
        if let Ok(catalog) = ciborium::from_reader::<CatalogState, _>(bytes.as_slice()) {
            tracing::info!(
                "Restored cached catalog state: {} entries",
                catalog.entries.len()
            );
            *CATALOG_STATE.write() = Some(catalog);
        }
    }

    let mut available = 0u8;
    for shard_id in 0u8..16 {
        let key = format!("shard_state_{}", shard_id);
        if let Some(bytes) = load_from_local_storage(&key) {
            if let Ok(shard) = ciborium::from_reader::<ShardState, _>(bytes.as_slice()) {
                SHARD_STATES.write().insert(shard_id, shard);
                available += 1;
            }
        }
    }
    if available > 0 {
        tracing::info!("Restored {} cached shard states", available);
        *SHARDS_AVAILABLE.write() = available;
    }
}

fn cache_to_local_storage(key: &str, data: &[u8]) {
    let window = match web_sys::window() {
        Some(w) => w,
        None => return,
    };
    let storage = match window.local_storage() {
        Ok(Some(s)) => s,
        _ => return,
    };
    // Encode as hex since localStorage is string-only
    let hex = data
        .iter()
        .map(|b| format!("{:02x}", b))
        .collect::<String>();
    let _ = storage.set_item(key, &hex);
}

fn load_from_local_storage(key: &str) -> Option<Vec<u8>> {
    let window = web_sys::window()?;
    let storage = window.local_storage().ok()??;
    let hex = storage.get_item(key).ok()??;
    super::hex_decode(&hex)
}
