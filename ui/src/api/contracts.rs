use freenet_stdlib::client_api::{ClientRequest, ContractRequest};
use freenet_stdlib::prelude::{ContractInstanceId, ContractKey};
use web_sys::WebSocket;

use crate::state::{CATALOG_STATE, SHARDS_AVAILABLE, SHARD_STATES};
use search_common::types::{CatalogState, ShardState};

use super::node_api::send_request;

// Auto-generated by deploy-helper. Regenerate with: cargo run -p deploy-helper
const CATALOG_INSTANCE_ID: [u8; 32] = [143, 10, 66, 224, 203, 215, 29, 116, 59, 1, 152, 71, 32, 123, 31, 64, 166, 76, 65, 168, 14, 79, 65, 37, 196, 24, 16, 19, 3, 230, 21, 215];

const SHARD_INSTANCE_IDS: [[u8; 32]; 16] = [
    [202, 83, 23, 225, 169, 154, 126, 1, 105, 27, 73, 247, 84, 127, 175, 27, 41, 141, 171, 243, 251, 27, 192, 2, 148, 98, 49, 107, 49, 9, 60, 104],
    [196, 22, 95, 58, 248, 71, 117, 199, 32, 116, 204, 136, 2, 13, 139, 50, 113, 178, 50, 19, 140, 32, 221, 32, 218, 234, 201, 5, 200, 16, 19, 5],
    [231, 179, 235, 172, 217, 247, 183, 4, 132, 215, 177, 84, 159, 210, 145, 240, 128, 149, 118, 179, 121, 255, 75, 149, 34, 185, 11, 109, 225, 14, 150, 183],
    [167, 52, 50, 2, 125, 241, 76, 59, 36, 191, 99, 112, 116, 221, 188, 181, 127, 251, 57, 169, 66, 251, 126, 158, 36, 185, 27, 216, 153, 15, 78, 187],
    [255, 101, 114, 192, 132, 64, 134, 16, 204, 10, 46, 204, 169, 203, 201, 156, 94, 239, 118, 230, 102, 197, 227, 85, 204, 209, 128, 23, 178, 182, 166, 237],
    [165, 163, 71, 53, 27, 226, 165, 113, 9, 194, 214, 229, 253, 149, 116, 60, 75, 181, 231, 57, 7, 8, 205, 236, 39, 69, 137, 101, 69, 63, 194, 148],
    [128, 115, 1, 185, 254, 155, 88, 60, 11, 85, 168, 25, 153, 50, 194, 85, 130, 129, 95, 206, 103, 157, 132, 175, 129, 90, 144, 0, 173, 182, 50, 150],
    [33, 93, 134, 25, 136, 158, 212, 179, 50, 14, 225, 192, 40, 176, 240, 77, 216, 18, 45, 214, 126, 241, 2, 87, 127, 213, 6, 56, 7, 108, 86, 75],
    [232, 67, 20, 26, 139, 72, 208, 129, 51, 129, 222, 60, 218, 204, 42, 232, 16, 251, 32, 167, 110, 79, 251, 12, 247, 72, 204, 172, 182, 218, 115, 74],
    [125, 222, 85, 67, 154, 78, 169, 227, 87, 231, 83, 174, 11, 156, 21, 179, 64, 31, 71, 82, 2, 64, 207, 68, 129, 237, 12, 206, 245, 230, 173, 78],
    [16, 146, 209, 112, 20, 133, 128, 111, 38, 62, 214, 144, 159, 216, 23, 63, 105, 113, 42, 115, 203, 251, 175, 162, 190, 52, 14, 250, 50, 113, 230, 102],
    [111, 37, 110, 179, 225, 243, 243, 104, 37, 98, 176, 8, 101, 124, 217, 135, 92, 92, 36, 32, 104, 150, 215, 79, 113, 168, 232, 76, 166, 48, 29, 25],
    [249, 134, 245, 56, 72, 164, 125, 199, 83, 120, 196, 220, 240, 124, 224, 222, 66, 93, 199, 123, 102, 27, 205, 48, 216, 230, 236, 189, 185, 23, 214, 118],
    [225, 135, 35, 173, 236, 9, 147, 52, 251, 223, 214, 10, 25, 43, 244, 68, 97, 211, 210, 154, 78, 151, 220, 95, 240, 117, 20, 117, 116, 104, 121, 198],
    [159, 22, 86, 202, 209, 134, 237, 182, 96, 216, 216, 140, 14, 35, 164, 83, 38, 116, 137, 230, 245, 232, 170, 177, 49, 43, 200, 0, 157, 188, 152, 7],
    [193, 124, 4, 70, 235, 141, 97, 24, 126, 53, 198, 97, 85, 14, 30, 1, 186, 23, 252, 141, 28, 237, 211, 81, 86, 68, 75, 238, 67, 211, 229, 122],
];

fn catalog_instance_id() -> ContractInstanceId {
    ContractInstanceId::new(CATALOG_INSTANCE_ID)
}

fn shard_instance_id(shard_id: u8) -> ContractInstanceId {
    ContractInstanceId::new(SHARD_INSTANCE_IDS[shard_id as usize])
}

/// Subscribe to the catalog contract state with updates.
pub fn subscribe_catalog(ws: &WebSocket) {
    let request = ClientRequest::ContractOp(ContractRequest::Get {
        key: catalog_instance_id(),
        return_contract_code: false,
        subscribe: true,
        blocking_subscribe: false,
    });
    send_request(ws, &request);
    tracing::info!("Subscribed to catalog contract");
}

/// Subscribe to a single shard contract state with updates.
pub fn subscribe_shard(ws: &WebSocket, shard_id: u8) {
    let request = ClientRequest::ContractOp(ContractRequest::Get {
        key: shard_instance_id(shard_id),
        return_contract_code: false,
        subscribe: true,
        blocking_subscribe: false,
    });
    send_request(ws, &request);
    tracing::debug!("Subscribed to shard contract {}", shard_id);
}

/// Handle a catalog contract GET response: deserialize CBOR and update signals.
pub fn handle_catalog_response(state_bytes: &[u8]) {
    match ciborium::from_reader::<CatalogState, _>(state_bytes) {
        Ok(catalog) => {
            tracing::info!(
                "Catalog state loaded: {} entries, {} contributors",
                catalog.entries.len(),
                catalog.contributors.len()
            );
            cache_to_local_storage("catalog_state", state_bytes);
            *CATALOG_STATE.write() = Some(catalog);
        }
        Err(e) => {
            tracing::warn!("Failed to deserialize catalog state: {}", e);
        }
    }
}

/// Handle a shard contract GET response: deserialize CBOR and update signals.
pub fn handle_shard_response(state_bytes: &[u8]) {
    match ciborium::from_reader::<ShardState, _>(state_bytes) {
        Ok(shard) => {
            let shard_id = shard.shard_id;
            let term_count = shard.index.len();
            tracing::debug!("Shard {} state loaded: {} terms", shard_id, term_count,);
            cache_to_local_storage(&format!("shard_state_{}", shard_id), state_bytes);

            let mut states = SHARD_STATES.write();
            states.insert(shard_id, shard);
            let available = states.len() as u8;
            drop(states);
            *SHARDS_AVAILABLE.write() = available;
        }
        Err(e) => {
            tracing::warn!("Failed to deserialize shard state: {}", e);
        }
    }
}

/// Check if a contract key matches the catalog contract.
pub fn is_catalog_key(key: &ContractKey) -> bool {
    key.id().as_bytes() == catalog_instance_id().as_bytes()
}

/// Check if a contract key matches any shard contract, returning the shard_id.
pub fn matching_shard_id(key: &ContractKey) -> Option<u8> {
    let key_bytes = key.id().as_bytes();
    (0u8..16).find(|&shard_id| key_bytes == shard_instance_id(shard_id).as_bytes())
}

/// Get the catalog contract instance ID (for use in Update requests).
pub fn catalog_contract_key() -> ContractInstanceId {
    catalog_instance_id()
}

/// Get a shard contract instance ID (for use in Update requests).
pub fn shard_contract_key(shard_id: u8) -> ContractInstanceId {
    shard_instance_id(shard_id)
}

/// Load cached catalog and shard states from localStorage on startup.
pub fn load_cached_states() {
    if let Some(bytes) = load_from_local_storage("catalog_state") {
        if let Ok(catalog) = ciborium::from_reader::<CatalogState, _>(bytes.as_slice()) {
            tracing::info!(
                "Restored cached catalog state: {} entries",
                catalog.entries.len()
            );
            *CATALOG_STATE.write() = Some(catalog);
        }
    }

    let mut available = 0u8;
    for shard_id in 0u8..16 {
        let key = format!("shard_state_{}", shard_id);
        if let Some(bytes) = load_from_local_storage(&key) {
            if let Ok(shard) = ciborium::from_reader::<ShardState, _>(bytes.as_slice()) {
                SHARD_STATES.write().insert(shard_id, shard);
                available += 1;
            }
        }
    }
    if available > 0 {
        tracing::info!("Restored {} cached shard states", available);
        *SHARDS_AVAILABLE.write() = available;
    }
}

fn cache_to_local_storage(key: &str, data: &[u8]) {
    let window = match web_sys::window() {
        Some(w) => w,
        None => return,
    };
    let storage = match window.local_storage() {
        Ok(Some(s)) => s,
        _ => return,
    };
    // Encode as hex since localStorage is string-only
    let hex = data
        .iter()
        .map(|b| format!("{:02x}", b))
        .collect::<String>();
    let _ = storage.set_item(key, &hex);
}

fn load_from_local_storage(key: &str) -> Option<Vec<u8>> {
    let window = web_sys::window()?;
    let storage = window.local_storage().ok()??;
    let hex = storage.get_item(key).ok()??;
    super::hex_decode(&hex)
}
