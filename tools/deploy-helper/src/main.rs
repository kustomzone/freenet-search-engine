use search_common::types::{CatalogParameters, CatalogState, ShardState};
use std::collections::BTreeMap;
use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    let args: Vec<String> = std::env::args().collect();
    let output_dir = args.get(1).map(|s| s.as_str()).unwrap_or("target/deploy");

    let out = Path::new(output_dir);
    fs::create_dir_all(out).expect("failed to create output dir");

    // Generate catalog parameters
    let catalog_params = CatalogParameters {
        protocol_version: 1,
        shard_count: 16,
        confirmation_weight_threshold: 3,
        entry_ttl_days: 90,
    };
    write_cbor(out.join("catalog-params.cbor"), &catalog_params);
    println!("wrote catalog-params.cbor");

    // Generate empty catalog state
    let catalog_state = CatalogState {
        entries: BTreeMap::new(),
        contributors: BTreeMap::new(),
    };
    write_cbor(out.join("catalog-state.cbor"), &catalog_state);
    println!("wrote catalog-state.cbor");

    // Generate 16 shard states and parameters (empty, with shard_id)
    // Each shard needs distinct parameters so fdev derives a unique contract key.
    for shard_id in 0u8..16 {
        let shard_state = ShardState {
            shard_id,
            index: BTreeMap::new(),
        };
        let state_file = format!("shard-{}-state.cbor", shard_id);
        write_cbor(out.join(&state_file), &shard_state);

        // Parameters: CBOR-encoded shard_id (unique per shard â†’ unique contract key)
        let params_file = format!("shard-{}-params.cbor", shard_id);
        write_cbor(out.join(&params_file), &shard_id);

        println!("wrote {} + {}", state_file, params_file);
    }

    // Generate webapp signing keypair
    let signing_key = ed25519_dalek::SigningKey::generate(&mut rand::rngs::OsRng);
    let verifying_key = signing_key.verifying_key();

    // Parameters for web container = 32-byte public key
    fs::write(out.join("webapp-params.bin"), verifying_key.to_bytes())
        .expect("failed to write webapp params");
    println!("wrote webapp-params.bin (public key)");

    // Save secret key for signing
    fs::write(out.join("webapp-secret.bin"), signing_key.to_bytes())
        .expect("failed to write webapp secret");
    println!("wrote webapp-secret.bin (keep secret!)");

    // Generate Rust source snippet with contract IDs for the UI
    generate_contract_ids_snippet(out);

    println!("\nAll deploy artifacts written to {}", output_dir);
}

fn generate_contract_ids_snippet(out: &Path) {
    let catalog_wasm = "target/wasm32-unknown-unknown/release/contract_catalog.wasm";
    let shard_wasm = "target/wasm32-unknown-unknown/release/contract_fulltext_shard.wasm";

    let catalog_id = fdev_get_contract_id(catalog_wasm, &out.join("catalog-params.cbor"));

    let mut snippet = String::new();
    snippet.push_str("// Auto-generated by deploy-helper. Do not edit.\n");
    snippet.push_str("// Regenerate with: cargo run -p deploy-helper\n\n");
    snippet.push_str(&format!(
        "const CATALOG_INSTANCE_ID: [u8; 32] = {:?};\n\n",
        catalog_id
    ));

    snippet.push_str("const SHARD_INSTANCE_IDS: [[u8; 32]; 16] = [\n");
    for shard_id in 0u8..16 {
        let params_path = out.join(format!("shard-{}-params.cbor", shard_id));
        let shard_instance_id = fdev_get_contract_id(shard_wasm, &params_path);
        snippet.push_str(&format!("    {:?},\n", shard_instance_id));
    }
    snippet.push_str("];\n");

    let snippet_path = out.join("contract_ids.rs");
    fs::write(&snippet_path, &snippet).unwrap();
    println!("wrote contract_ids.rs (copy into ui/src/api/contracts.rs)");
}

/// Call `fdev get-contract-id` and decode the base58 output to [u8; 32].
fn fdev_get_contract_id(code_path: &str, params_path: &Path) -> [u8; 32] {
    let output = Command::new("fdev")
        .args(["get-contract-id", "--code", code_path, "--parameters"])
        .arg(params_path)
        .output()
        .expect("failed to run fdev get-contract-id");

    if !output.status.success() {
        panic!(
            "fdev get-contract-id failed: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    let id_str = String::from_utf8(output.stdout)
        .expect("invalid UTF-8 from fdev")
        .trim()
        .to_string();

    let bytes = bs58::decode(&id_str)
        .into_vec()
        .unwrap_or_else(|e| panic!("failed to decode base58 '{}': {}", id_str, e));

    if bytes.len() != 32 {
        panic!(
            "expected 32 bytes from fdev, got {} for '{}'",
            bytes.len(),
            id_str
        );
    }

    let mut arr = [0u8; 32];
    arr.copy_from_slice(&bytes);
    arr
}

fn write_cbor<T: serde::Serialize>(path: std::path::PathBuf, value: &T) {
    let mut buf = Vec::new();
    ciborium::into_writer(value, &mut buf).expect("failed to serialize CBOR");
    fs::write(path, buf).expect("failed to write file");
}
